<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAG Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Include marked library -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            /* This line attempts to use system UI fonts:
            -apple-system and BlinkMacSystemFont for Apple systems,
            "Segoe UI" for Windows,
            Roboto for Android and some Chrome OS,
            "Helvetica Neue" for older macOS versions,
            Arial as a generic fallback,
            sans-serif as a final generic fallback. */
        }
        html, body {
            height: 100%; /* Full height for the html and body */
            margin: 0; /* Remove default margin */
            padding: 0; /* Remove default padding */
            display: flex; /* Enable flexbox */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            background-color: #f4f4f4; /* Background color */
            box-sizing: border-box; /* Border and padding included in width/height */
        }
        #container {
            display: flex; /* Flex container for the panels */
            width: 90vw; /* 90% of viewport width */
            height: 100vh; /* 80% of viewport height */
            padding: 20px; /* Padding around the container */
            box-sizing: border-box; /* Include padding in the width and height calculation */
        }
        #left-panel {
            width: 40%;
            height: 100%; /* Full height of the container */
            overflow-y: auto;
            padding: 10px;
            border: 1px solid gray;
            border-radius: 10px;
            font-size: 12px;
            box-sizing: border-box;
            direction: rtl; /* Right to Left text direction for scrollbar */
            margin-right: 20px;
        }
        #left-panel > * {
            direction: ltr; /* Left to Right text direction for contents */
        }
        #svg-container {
            flex: 1; /* Take remaining space */
            flex-direction: column;
            margin-right: 20px;
            /* height: 60%; Full height of the container */
            /* margin-left: 2%; Gutter between panels */
        }
        #svg {
            width: 100%;
            height: 60%;
            border: solid 1px black;
            border-radius: 10px;
        }
        #states-panel {
            flex-grow: 1;
            margin-top: 20px; /*Space between the graph and the states panel*/
            border: solid 1px gray;
            border-radius: 10px;
            padding: 10px;
            /* display: flex; */
            flex-direction: column; /* Organize items vertically */
            align-items: center;
            overflow-y: auto; /* Enable scroll if content overflows */
        }

        .state-bar {
            width: 100%; /* Full width to align labels and bars */
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Align items to the left */
            margin: 5px 0;
        }

        .state-bar-label {
            min-width: 150px; /* Ensure the label has a consistent width */
            text-align: right; /* Align text to the right */
            margin-right: 10px; /* Space between label and bar */
            font-size: 10px;
        }

        .state-bar-graph {
            height: 15px;
            background-color: #007BFF;
            color: white;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        text {
            font-size: 14px;
            text-anchor: middle;
            pointer-events: none;
            fill: #333;
        }
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1.5px;
            fill: none;
            marker-end: url(#arrow);
        }
        .node circle {
            fill: #66c2a5;
            stroke: #333;
            stroke-width: 1.5px;
        }
        .node-info {
            margin-bottom: 10px;
            padding: 10px;
            cursor: pointer;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        .node-info:hover {
            background-color: #eee;
        }
        .selected-message {
            outline: 2px solid blue;
        }

        .state-tags {
            display: flex; /* Flexbox to arrange tags in a row */
            flex-wrap: wrap; /* Allow wrapping onto the next line */
            gap: 5px; /* Space between tags */
            margin-top: 10px; /* Space above the tag container */
        }

        .state-tag {
            background-color: #007BFF; /* Blue background */
            color: white; /* White text */
            padding: 2px 8px; /* Padding inside the tag */
            border-radius: 10px; /* Rounded corners */
            font-size: 0.8em; /* Smaller font size for tags */
        }

        #reset-view {
            cursor: pointer;
            background-color: #ffffff;
            border: 1px solid #cccccc;
            border-radius: 5px;
        }

        #reset-view:hover {
            color: #0056b3;
        }


    </style>
</head>
<body>
    <div id="container">
        <div id="left-panel">
            <!-- Node information will be populated here -->
        </div>
        <div id="svg-container">
            <svg id="svg"></svg>
            <i id="reset-view" class="fas fa-sync-alt" style="position: absolute; bottom: 10px; right: 10px; font-size: 24px; color: #007BFF; cursor: pointer;"></i>
            <!-- New panel for states -->
            <div id="states-panel">
                <!-- States bar chart will be populated here -->
            </div>
        </div>

    </div>
    <script>
        let data = "__DAG_DATA__";

        const svg = d3.select("#svg");
        const svgContainer = d3.select("#svg-container");
        const width = svg.node().getBoundingClientRect().width;
        const height = svg.node().getBoundingClientRect().height;

        const statesChart = d3.select("#states-panel");
        const statesWidth = statesChart.node().getBoundingClientRect().width;
        const statesHeight = statesChart.node().getBoundingClientRect().height;

        let stateCounts = {};
        data.nodes.forEach(node => {
            if (node.profile.states) {
                node.profile.states.forEach(state => {
                    stateCounts[state.name] = (stateCounts[state.name] || 0) + 1;
                });
            }
        });

        const totalStates = Object.keys(stateCounts).reduce((sum, key) => sum + stateCounts[key], 0);
        // Modify the bar chart rendering section in the script
        // Modify the bar chart rendering section in the script
        statesChart.selectAll(".state-bar")
            .data(Object.entries(stateCounts))
            .enter()
            .append("div")
            .classed("state-bar", true)
            .each(function(d) {
                const div = d3.select(this);
                div.append("div")
                    .classed("state-bar-label", true)
                    .text(d[0]); // Set the label

                div.append("div")
                    .classed("state-bar-graph", true)
                    .style("width", `${(d[1] / totalStates) * 100}%`) // Dynamic width based on data
                    .text(`(${d[1]})`); // Set the text inside the bar
            });


        const zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .on("zoom", (event) => {
                container.attr("transform", event.transform);
            });

        svg.call(zoom);

        const container = svg.append("g");

        const link = container.selectAll(".link")
            .data(data.links)
            .enter().append("line")
            .attr("class", "link")
            .attr("marker-end", "url(#arrow)");

        const nodeRadius = 30;
        const simulation = d3.forceSimulation(data.nodes)
            .force("link", d3.forceLink(data.links).id(d => d.index).distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide(nodeRadius + 1));

        const node = container.selectAll(".node")
            .data(data.nodes)
            .enter().append("g")
            .attr("class", "node")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended))
            .on("click", (event, d) => {
                const index = d.index;
                const nodeInfoElement = document.getElementById(`node-info-${index}`);
                if (nodeInfoElement) {
                    // Scroll to the corresponding message
                    nodeInfoElement.scrollIntoView({ behavior: "smooth", block: "start", inline: "nearest" });

                    // Remove outline from previously selected message
                    const previousSelected = document.querySelector(".selected-message");
                    if (previousSelected) {
                        previousSelected.classList.remove("selected-message");
                    }

                    // Add outline to the selected message
                    nodeInfoElement.classList.add("selected-message");
                }
            });

        node.append("circle")
            .attr("r", nodeRadius);

        node.append("text")
            .attr("dy", "0.35em")
            .text(d => d.profile.message.source);

        simulation.on("tick", () => {
            link.attr("x1", d => d.source.x)
                .attr("y1", d => d.source.y)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.y);

            node.attr("transform", d => `translate(${d.x},${d.y})`);
        });

        document.getElementById('reset-view').addEventListener('click', function() {
            fitGraph(); // Resets the graph zoom and position
        });


        // Ensure that the fitGraph function also considers the height of the states panel
        function fitGraph() {
            simulation.stop(); // Stop the simulation temporarily

            let bounds = getGraphBounds(), // Get the bounds of the graph
                widthScale = width / (bounds.maxX - bounds.minX),
                heightScale = (height - 40) / (bounds.maxY - bounds.minY), // Adjust for the height of the states panel
                scale = Math.min(widthScale, heightScale) * 0.8, // Scale down a bit to add padding
                translate = [
                    (width / 2) - scale * (bounds.minX + (bounds.maxX - bounds.minX) / 2),
                    (height / 2) - scale * (bounds.minY + (bounds.maxY - bounds.minY) / 2) - 20 // Adjust translate to consider the panel
                ];

            svg.transition()
                .duration(500)
                .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
        }

        // Function to get the graphical bounds of the nodes
        function getGraphBounds() {
            let minX = Infinity,
                maxX = -Infinity,
                minY = Infinity,
                maxY = -Infinity;

            node.each(d => {
                if (d.x < minX) minX = d.x;
                if (d.x > maxX) maxX = d.x;
                if (d.y < minY) minY = d.y;
                if (d.y > maxY) maxY = d.y;
            });

            return { minX, maxX, minY, maxY };
        }

        // simulation.on("end", fitGraph); // Call fitGraph when the simulation stabilizes
        let initialFitGraph = false;
        let isSimulationEnded = false;

        window.onload = function() {
            if (isSimulationEnded && !initialFitGraph) {
                fitGraph();
                initialFitGraph = true;
            }
        };

        simulation.on("end", function() {
            isSimulationEnded = true;
            if (!initialFitGraph) {
                fitGraph();
                initialFitGraph = true;
            }
        });

        // Add this function at the beginning of your script
        function processMarkdown(md) {
            md = md.replace(/>>>>>>>>/g, "**");
            md = md.replace(/\n/g, "\n\n");
            return md;
        }

        // Then modify the existing code
        const leftPanel = d3.select("#left-panel");
        const nodeInfo = leftPanel.selectAll(".node-info")
            .data(data.nodes)
            .enter().append("div")
            .attr("class", "node-info")
            .attr("id", (d, i) => `node-info-${i}`)
            .html(d => {
                let contentHtml = marked.parse(processMarkdown(d.profile.message.content));
                let statesHtml = '';

                if (d.profile.states && d.profile.states.length > 0) {
                    statesHtml += '<div class="state-tags">';
                    d.profile.states.forEach(state => {
                        statesHtml += `<span class="state-tag">${state.name}</span>`;
                    });
                    statesHtml += '</div>';
                }

                return contentHtml + statesHtml;
            });

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    </script>
</body>
</html>
