{
  "id": "gallery_default",
  "name": "Default Component Gallery",
  "metadata": {
    "author": "AutoGen Team",
    "created_at": "2025-02-01T17:12:38.179093",
    "updated_at": "2025-02-01T17:12:38.701658",
    "version": "1.0.0",
    "description": "A default gallery containing basic components for human-in-loop conversations",
    "tags": ["human-in-loop", "assistant", "web agents"],
    "license": "MIT",
    "homepage": null,
    "category": "conversation",
    "last_synced": null
  },
  "items": {
    "teams": [
      {
        "provider": "autogen_agentchat.teams.RoundRobinGroupChat",
        "component_type": "team",
        "version": 1,
        "component_version": 1,
        "description": "A single AssistantAgent (with a calculator tool) in a RoundRobinGroupChat team. ",
        "label": "Default Team",
        "config": {
          "participants": [
            {
              "provider": "autogen_agentchat.agents.AssistantAgent",
              "component_type": "agent",
              "version": 1,
              "component_version": 1,
              "description": "An agent that provides assistance with tool use.",
              "label": "AssistantAgent",
              "config": {
                "name": "assistant_agent",
                "model_client": {
                  "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
                  "component_type": "model",
                  "version": 1,
                  "component_version": 1,
                  "description": "Chat completion client for OpenAI hosted models.",
                  "label": "OpenAIChatCompletionClient",
                  "config": {
                    "model": "gpt-4o-mini"
                  }
                },
                "tools": [
                  {
                    "provider": "autogen_core.tools.FunctionTool",
                    "component_type": "tool",
                    "version": 1,
                    "component_version": 1,
                    "description": "Create custom tools by wrapping standard Python functions.",
                    "label": "FunctionTool",
                    "config": {
                      "source_code": "def calculator(a: float, b: float, operator: str) -> str:\n        try:\n            if operator == \"+\":\n                return str(a + b)\n            elif operator == \"-\":\n                return str(a - b)\n            elif operator == \"*\":\n                return str(a * b)\n            elif operator == \"/\":\n                if b == 0:\n                    return \"Error: Division by zero\"\n                return str(a / b)\n            else:\n                return \"Error: Invalid operator. Please use +, -, *, or /\"\n        except Exception as e:\n            return f\"Error: {str(e)}\"\n",
                      "name": "calculator",
                      "description": "A simple calculator that performs basic arithmetic operations",
                      "global_imports": [],
                      "has_cancellation_support": false
                    }
                  }
                ],
                "handoffs": [],
                "model_context": {
                  "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
                  "component_type": "chat_completion_context",
                  "version": 1,
                  "component_version": 1,
                  "description": "An unbounded chat completion context that keeps a view of the all the messages.",
                  "label": "UnboundedChatCompletionContext",
                  "config": {}
                },
                "description": "An agent that provides assistance with ability to use tools.",
                "system_message": "You are a helpful assistant. Solve tasks carefully. When done, say TERMINATE.",
                "model_client_stream": false,
                "reflect_on_tool_use": false,
                "tool_call_summary_format": "{result}"
              }
            }
          ],
          "termination_condition": {
            "provider": "autogen_agentchat.base.OrTerminationCondition",
            "component_type": "termination",
            "version": 1,
            "component_version": 1,
            "label": "OrTerminationCondition",
            "config": {
              "conditions": [
                {
                  "provider": "autogen_agentchat.conditions.TextMentionTermination",
                  "component_type": "termination",
                  "version": 1,
                  "component_version": 1,
                  "description": "Terminate the conversation if a specific text is mentioned.",
                  "label": "TextMentionTermination",
                  "config": {
                    "text": "TERMINATE"
                  }
                },
                {
                  "provider": "autogen_agentchat.conditions.MaxMessageTermination",
                  "component_type": "termination",
                  "version": 1,
                  "component_version": 1,
                  "description": "Terminate the conversation after a maximum number of messages have been exchanged.",
                  "label": "MaxMessageTermination",
                  "config": {
                    "max_messages": 10
                  }
                }
              ]
            }
          }
        }
      },
      {
        "provider": "autogen_agentchat.teams.SelectorGroupChat",
        "component_type": "team",
        "version": 1,
        "component_version": 1,
        "description": "A group chat team that have participants takes turn to publish a message\n    to all, using a ChatCompletion model to select the next speaker after each message.",
        "label": "Web Agent Team (Operator)",
        "config": {
          "participants": [
            {
              "provider": "autogen_ext.agents.web_surfer.MultimodalWebSurfer",
              "component_type": "agent",
              "version": 1,
              "component_version": 1,
              "description": "MultimodalWebSurfer is a multimodal agent that acts as a web surfer that can search the web and visit web pages.",
              "label": "MultimodalWebSurfer",
              "config": {
                "name": "websurfer_agent",
                "model_client": {
                  "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
                  "component_type": "model",
                  "version": 1,
                  "component_version": 1,
                  "description": "Chat completion client for OpenAI hosted models.",
                  "label": "OpenAIChatCompletionClient",
                  "config": {
                    "model": "gpt-4o-mini"
                  }
                },
                "description": "an agent that solves tasks by browsing the web",
                "headless": true,
                "start_page": "https://www.bing.com/",
                "animate_actions": false,
                "to_save_screenshots": false,
                "use_ocr": false,
                "to_resize_viewport": true
              }
            },
            {
              "provider": "autogen_agentchat.agents.AssistantAgent",
              "component_type": "agent",
              "version": 1,
              "component_version": 1,
              "description": "An agent that provides assistance with tool use.",
              "label": "AssistantAgent",
              "config": {
                "name": "assistant_agent",
                "model_client": {
                  "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
                  "component_type": "model",
                  "version": 1,
                  "component_version": 1,
                  "description": "Chat completion client for OpenAI hosted models.",
                  "label": "OpenAIChatCompletionClient",
                  "config": {
                    "model": "gpt-4o-mini"
                  }
                },
                "tools": [],
                "handoffs": [],
                "model_context": {
                  "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
                  "component_type": "chat_completion_context",
                  "version": 1,
                  "component_version": 1,
                  "description": "An unbounded chat completion context that keeps a view of the all the messages.",
                  "label": "UnboundedChatCompletionContext",
                  "config": {}
                },
                "description": "an agent that verifies and summarizes information",
                "system_message": "You are a task verification assistant who is working with a web surfer agent to solve tasks. At each point, check if the task has been completed as requested by the user. If the websurfer_agent responds and the task has not yet been completed, respond with what is left to do and then say 'keep going'. If and only when the task has been completed, summarize and present a final answer that directly addresses the user task in detail and then respond with TERMINATE.",
                "model_client_stream": false,
                "reflect_on_tool_use": false,
                "tool_call_summary_format": "{result}"
              }
            },
            {
              "provider": "autogen_agentchat.agents.UserProxyAgent",
              "component_type": "agent",
              "version": 1,
              "component_version": 1,
              "description": "An agent that can represent a human user through an input function.",
              "label": "UserProxyAgent",
              "config": {
                "name": "user_proxy",
                "description": "a human user that should be consulted only when the assistant_agent is unable to verify the information provided by the websurfer_agent"
              }
            }
          ],
          "model_client": {
            "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
            "component_type": "model",
            "version": 1,
            "component_version": 1,
            "description": "Chat completion client for OpenAI hosted models.",
            "label": "OpenAIChatCompletionClient",
            "config": {
              "model": "gpt-4o-mini"
            }
          },
          "termination_condition": {
            "provider": "autogen_agentchat.base.OrTerminationCondition",
            "component_type": "termination",
            "version": 1,
            "component_version": 1,
            "label": "OrTerminationCondition",
            "config": {
              "conditions": [
                {
                  "provider": "autogen_agentchat.conditions.MaxMessageTermination",
                  "component_type": "termination",
                  "version": 1,
                  "component_version": 1,
                  "description": "Terminate the conversation after a maximum number of messages have been exchanged.",
                  "label": "MaxMessageTermination",
                  "config": {
                    "max_messages": 20
                  }
                },
                {
                  "provider": "autogen_agentchat.conditions.TextMentionTermination",
                  "component_type": "termination",
                  "version": 1,
                  "component_version": 1,
                  "description": "Terminate the conversation if a specific text is mentioned.",
                  "label": "TextMentionTermination",
                  "config": {
                    "text": "TERMINATE"
                  }
                }
              ]
            }
          },
          "selector_prompt": "You are the cordinator of role play game. The following roles are available:\n{roles}. Given a task, the websurfer_agent will be tasked to address it by browsing the web and providing information.  The assistant_agent will be tasked with verifying the information provided by the websurfer_agent and summarizing the information to present a final answer to the user. If the task  needs assistance from a human user (e.g., providing feedback, preferences, or the task is stalled), you should select the user_proxy role to provide the necessary information.\n\nRead the following conversation. Then select the next role from {participants} to play. Only return the role.\n\n{history}\n\nRead the above conversation. Then select the next role from {participants} to play. Only return the role.",
          "allow_repeated_speaker": false
        }
      }
    ],
    "components": {
      "agents": [
        {
          "provider": "autogen_agentchat.agents.AssistantAgent",
          "component_type": "agent",
          "version": 1,
          "component_version": 1,
          "description": "An agent that provides assistance with ability to use tools.",
          "label": "AssistantAgent",
          "config": {
            "name": "assistant_agent",
            "model_client": {
              "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
              "component_type": "model",
              "version": 1,
              "component_version": 1,
              "description": "Chat completion client for OpenAI hosted models.",
              "label": "OpenAIChatCompletionClient",
              "config": {
                "model": "gpt-4o-mini"
              }
            },
            "tools": [
              {
                "provider": "autogen_core.tools.FunctionTool",
                "component_type": "tool",
                "version": 1,
                "component_version": 1,
                "description": "Create custom tools by wrapping standard Python functions.",
                "label": "FunctionTool",
                "config": {
                  "source_code": "def calculator(a: float, b: float, operator: str) -> str:\n        try:\n            if operator == \"+\":\n                return str(a + b)\n            elif operator == \"-\":\n                return str(a - b)\n            elif operator == \"*\":\n                return str(a * b)\n            elif operator == \"/\":\n                if b == 0:\n                    return \"Error: Division by zero\"\n                return str(a / b)\n            else:\n                return \"Error: Invalid operator. Please use +, -, *, or /\"\n        except Exception as e:\n            return f\"Error: {str(e)}\"\n",
                  "name": "calculator",
                  "description": "A simple calculator that performs basic arithmetic operations",
                  "global_imports": [],
                  "has_cancellation_support": false
                }
              }
            ],
            "handoffs": [],
            "model_context": {
              "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
              "component_type": "chat_completion_context",
              "version": 1,
              "component_version": 1,
              "description": "An unbounded chat completion context that keeps a view of the all the messages.",
              "label": "UnboundedChatCompletionContext",
              "config": {}
            },
            "description": "An agent that provides assistance with ability to use tools.",
            "system_message": "You are a helpful assistant. Solve tasks carefully. When done, say TERMINATE.",
            "model_client_stream": false,
            "reflect_on_tool_use": false,
            "tool_call_summary_format": "{result}"
          }
        },
        {
          "provider": "autogen_ext.agents.web_surfer.MultimodalWebSurfer",
          "component_type": "agent",
          "version": 1,
          "component_version": 1,
          "description": "MultimodalWebSurfer is a multimodal agent that acts as a web surfer that can search the web and visit web pages.",
          "label": "MultimodalWebSurfer",
          "config": {
            "name": "websurfer_agent",
            "model_client": {
              "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
              "component_type": "model",
              "version": 1,
              "component_version": 1,
              "description": "Chat completion client for OpenAI hosted models.",
              "label": "OpenAIChatCompletionClient",
              "config": {
                "model": "gpt-4o-mini"
              }
            },
            "description": "an agent that solves tasks by browsing the web",
            "headless": true,
            "start_page": "https://www.bing.com/",
            "animate_actions": false,
            "to_save_screenshots": false,
            "use_ocr": false,
            "to_resize_viewport": true
          }
        },
        {
          "provider": "autogen_agentchat.agents.AssistantAgent",
          "component_type": "agent",
          "version": 1,
          "component_version": 1,
          "description": "An agent that provides assistance with tool use.",
          "label": "AssistantAgent",
          "config": {
            "name": "assistant_agent",
            "model_client": {
              "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
              "component_type": "model",
              "version": 1,
              "component_version": 1,
              "description": "Chat completion client for OpenAI hosted models.",
              "label": "OpenAIChatCompletionClient",
              "config": {
                "model": "gpt-4o-mini"
              }
            },
            "tools": [],
            "handoffs": [],
            "model_context": {
              "provider": "autogen_core.model_context.UnboundedChatCompletionContext",
              "component_type": "chat_completion_context",
              "version": 1,
              "component_version": 1,
              "description": "An unbounded chat completion context that keeps a view of the all the messages.",
              "label": "UnboundedChatCompletionContext",
              "config": {}
            },
            "description": "an agent that verifies and summarizes information",
            "system_message": "You are a task verification assistant who is working with a web surfer agent to solve tasks. At each point, check if the task has been completed as requested by the user. If the websurfer_agent responds and the task has not yet been completed, respond with what is left to do and then say 'keep going'. If and only when the task has been completed, summarize and present a final answer that directly addresses the user task in detail and then respond with TERMINATE.",
            "model_client_stream": false,
            "reflect_on_tool_use": false,
            "tool_call_summary_format": "{result}"
          }
        },
        {
          "provider": "autogen_agentchat.agents.UserProxyAgent",
          "component_type": "agent",
          "version": 1,
          "component_version": 1,
          "description": "An agent that can represent a human user through an input function.",
          "label": "UserProxyAgent",
          "config": {
            "name": "user_proxy",
            "description": "a human user that should be consulted only when the assistant_agent is unable to verify the information provided by the websurfer_agent"
          }
        }
      ],
      "models": [
        {
          "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
          "component_type": "model",
          "version": 1,
          "component_version": 1,
          "description": "Chat completion client for OpenAI hosted models.",
          "label": "OpenAIChatCompletionClient",
          "config": {
            "model": "gpt-4o-mini"
          }
        },
        {
          "provider": "autogen_ext.models.openai.OpenAIChatCompletionClient",
          "component_type": "model",
          "version": 1,
          "component_version": 1,
          "description": "Example on how to use the OpenAIChatCopletionClient with local models (Ollama, vllm etc).",
          "label": "Mistral-7B vllm",
          "config": {
            "model": "TheBloke/Mistral-7B-Instruct-v0.2-GGUF",
            "base_url": "http://localhost:1234/v1"
          }
        }
      ],
      "tools": [
        {
          "provider": "autogen_core.tools.FunctionTool",
          "component_type": "tool",
          "version": 1,
          "component_version": 1,
          "description": "Create custom tools by wrapping standard Python functions.",
          "label": "FunctionTool",
          "config": {
            "source_code": "def calculator(a: float, b: float, operator: str) -> str:\n        try:\n            if operator == \"+\":\n                return str(a + b)\n            elif operator == \"-\":\n                return str(a - b)\n            elif operator == \"*\":\n                return str(a * b)\n            elif operator == \"/\":\n                if b == 0:\n                    return \"Error: Division by zero\"\n                return str(a / b)\n            else:\n                return \"Error: Invalid operator. Please use +, -, *, or /\"\n        except Exception as e:\n            return f\"Error: {str(e)}\"\n",
            "name": "calculator",
            "description": "A simple calculator that performs basic arithmetic operations",
            "global_imports": [],
            "has_cancellation_support": false
          }
        },
        {
          "provider": "autogen_core.tools.FunctionTool",
          "component_type": "tool",
          "version": 1,
          "component_version": 1,
          "description": "A tool that generates images based on a text description using OpenAI's DALL-E model. Note: Requires OpenAI API key to function.",
          "label": "Image Generation Tool",
          "config": {
            "source_code": "async def generate_image(\n    query: str,\n    output_dir: Optional[Path] = None,\n    image_size: Literal[\"1024x1024\", \"512x512\", \"256x256\"] = \"1024x1024\"\n) -> List[str]:\n    \"\"\"\n    Generate images using OpenAI's DALL-E model based on a text description.\n\n    Args:\n        query: Natural language description of the desired image\n        output_dir: Directory to save generated images (default: current directory)\n        image_size: Size of generated image (1024x1024, 512x512, or 256x256)\n\n    Returns:\n        List[str]: Paths to the generated image files\n    \"\"\"\n    # Initialize the OpenAI client\n    client = OpenAI()\n\n    # Generate images using DALL-E 3\n    response = client.images.generate(\n        model=\"dall-e-3\",\n        prompt=query,\n        n=1,\n        response_format=\"b64_json\",\n        size=image_size\n    )\n\n    saved_files = []\n\n    # Process the response\n    if response.data:\n        for image_data in response.data:\n            # Generate a unique filename\n            file_name = f\"{uuid.uuid4()}.png\"\n\n            # Use output_dir if provided, otherwise use current directory\n            file_path = Path(output_dir) / file_name if output_dir else Path(file_name)\n\n            base64_str = image_data.b64_json \n            img = Image.open(io.BytesIO(base64.decodebytes(bytes(base64_str, \"utf-8\")))) \n\n            # Save the image to a file \n            img.save(file_path)  \n\n            saved_files.append(str(file_path))\n\n    return saved_files\n",
            "name": "generate_image",
            "description": "Generate images using DALL-E based on text descriptions.",
            "global_imports": [
              {
                "module": "typing",
                "imports": ["List", "Optional", "Literal"]
              },
              {
                "module": "pathlib",
                "imports": ["Path"]
              },
              {
                "module": "uuid",
                "imports": ["uuid4"]
              },
              {
                "module": "openai",
                "imports": ["OpenAI"]
              },
              {
                "module": "PIL",
                "imports": ["Image"]
              },
              {
                "module": "io",
                "imports": ["BytesIO"]
              },
              {
                "module": "base64",
                "imports": ["decodebytes"]
              }
            ],
            "has_cancellation_support": false
          }
        },
        {
          "provider": "autogen_core.tools.FunctionTool",
          "component_type": "tool",
          "version": 1,
          "component_version": 1,
          "description": "A tool that generates a PDF file from a list of images.Requires the PyFPDF and pillow library to function.",
          "label": "PDF Generation Tool",
          "config": {
            "source_code": "async def generate_pdf(\n    sections: List[Dict[str, Optional[str]]], \n    output_file: str = \"report.pdf\",\n    report_title: str = \"PDF Report\"\n) -> str:\n    \"\"\"\n    Generate a PDF report with formatted sections including text and images.\n\n    Args:\n        sections: List of dictionaries containing section details with keys:\n            - title: Section title\n            - level: Heading level (title, h1, h2)\n            - content: Section text content\n            - image: Optional image URL or file path\n        output_file: Name of output PDF file\n        report_title: Title shown at top of report\n\n    Returns:\n        str: Path to the generated PDF file\n    \"\"\"\n    def normalize_text(text: str) -> str:\n        \"\"\"Normalize Unicode text to ASCII.\"\"\"\n        return unicodedata.normalize('NFKD', text).encode('ascii', 'ignore').decode('ascii')\n\n    def get_image(image_url_or_path):\n        \"\"\"Fetch image from URL or local path.\"\"\"\n        if image_url_or_path.startswith((\"http://\", \"https://\")):\n            response = requests.get(image_url_or_path)\n            if response.status_code == 200:\n                return BytesIO(response.content)\n        elif Path(image_url_or_path).is_file():\n            return open(image_url_or_path, 'rb')\n        return None\n\n    def add_rounded_corners(img, radius=6):\n        \"\"\"Add rounded corners to an image.\"\"\"\n        mask = Image.new('L', img.size, 0)\n        draw = ImageDraw.Draw(mask)\n        draw.rounded_rectangle([(0, 0), img.size], radius, fill=255)\n        img = ImageOps.fit(img, mask.size, centering=(0.5, 0.5))\n        img.putalpha(mask)\n        return img\n\n    class PDF(FPDF):\n        \"\"\"Custom PDF class with header and content formatting.\"\"\"\n        def header(self):\n            self.set_font(\"Arial\", \"B\", 12)\n            normalized_title = normalize_text(report_title)\n            self.cell(0, 10, normalized_title, 0, 1, \"C\")\n\n        def chapter_title(self, txt): \n            self.set_font(\"Arial\", \"B\", 12)\n            normalized_txt = normalize_text(txt)\n            self.cell(0, 10, normalized_txt, 0, 1, \"L\")\n            self.ln(2)\n\n        def chapter_body(self, body):\n            self.set_font(\"Arial\", \"\", 12)\n            normalized_body = normalize_text(body)\n            self.multi_cell(0, 10, normalized_body)\n            self.ln()\n\n        def add_image(self, img_data):\n            img = Image.open(img_data)\n            img = add_rounded_corners(img)\n            img_path = Path(f\"temp_{uuid.uuid4().hex}.png\")\n            img.save(img_path, format=\"PNG\")\n            self.image(str(img_path), x=None, y=None, w=190 if img.width > 190 else img.width)\n            self.ln(10)\n            img_path.unlink()\n\n    # Initialize PDF\n    pdf = PDF()\n    pdf.add_page()\n    font_size = {\"title\": 16, \"h1\": 14, \"h2\": 12, \"body\": 12}\n\n    # Add sections\n    for section in sections:\n        title = section.get(\"title\", \"\")\n        level = section.get(\"level\", \"h1\")\n        content = section.get(\"content\", \"\")\n        image = section.get(\"image\")\n\n        pdf.set_font(\"Arial\", \"B\" if level in font_size else \"\", font_size.get(level, font_size[\"body\"]))\n        pdf.chapter_title(title)\n\n        if content:\n            pdf.chapter_body(content)\n\n        if image:\n            img_data = get_image(image)\n            if img_data:\n                pdf.add_image(img_data)\n                if isinstance(img_data, BytesIO):\n                    img_data.close()\n\n    pdf.output(output_file)\n    return output_file\n",
            "name": "generate_pdf",
            "description": "Generate PDF reports with formatted sections containing text and images",
            "global_imports": [
              {
                "module": "typing",
                "imports": ["List", "Dict", "Optional"]
              },
              {
                "module": "pathlib",
                "imports": ["Path"]
              },
              {
                "module": "uuid",
                "imports": ["uuid4"]
              },
              {
                "module": "requests",
                "imports": ["get"]
              },
              {
                "module": "fpdf",
                "imports": ["FPDF"]
              },
              {
                "module": "PIL",
                "imports": ["Image", "ImageDraw", "ImageOps"]
              },
              {
                "module": "io",
                "imports": ["BytesIO"]
              },
              {
                "module": "unicodedata",
                "imports": ["normalize"]
              }
            ],
            "has_cancellation_support": false
          }
        },
        {
          "provider": "autogen_core.tools.FunctionTool",
          "component_type": "tool",
          "version": 1,
          "component_version": 1,
          "description": "A tool that generates a webpage from a list of images. Requires beautifulsoup4 html2text library to function.",
          "label": "Webpage Generation Tool",
          "config": {
            "source_code": "async def fetch_webpage(\n    url: str,\n    include_images: bool = True,\n    max_length: Optional[int] = None,\n    headers: Optional[Dict[str, str]] = None\n) -> str:\n    \"\"\"\n    Fetch a webpage and convert it to markdown format.\n\n    Args:\n        url: The URL of the webpage to fetch\n        include_images: Whether to include image references in the markdown\n        max_length: Maximum length of the output markdown (if None, no limit)\n        headers: Optional HTTP headers for the request\n\n    Returns:\n        str: Markdown version of the webpage content\n\n    Raises:\n        ValueError: If the URL is invalid or the page can't be fetched\n    \"\"\"\n    # Use default headers if none provided\n    if headers is None:\n        headers = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n        }\n\n    try:\n        # Fetch the webpage\n        response = requests.get(url, headers=headers, timeout=10)\n        response.raise_for_status()\n\n        # Parse HTML\n        soup = BeautifulSoup(response.text, 'html.parser')\n\n        # Remove script and style elements\n        for script in soup([\"script\", \"style\"]):\n            script.decompose()\n\n        # Convert relative URLs to absolute\n        for tag in soup.find_all(['a', 'img']):\n            if tag.get('href'):\n                tag['href'] = urljoin(url, tag['href'])\n            if tag.get('src'):\n                tag['src'] = urljoin(url, tag['src'])\n\n        # Configure HTML to Markdown converter\n        h2t = html2text.HTML2Text()\n        h2t.body_width = 0  # No line wrapping\n        h2t.ignore_images = not include_images\n        h2t.ignore_emphasis = False\n        h2t.ignore_links = False\n        h2t.ignore_tables = False\n\n        # Convert to markdown\n        markdown = h2t.handle(str(soup))\n\n        # Trim if max_length is specified\n        if max_length and len(markdown) > max_length:\n            markdown = markdown[:max_length] + \"\\n...(truncated)\"\n\n        return markdown.strip()\n\n    except requests.RequestException as e:\n        raise ValueError(f\"Failed to fetch webpage: {str(e)}\")\n    except Exception as e:\n        raise ValueError(f\"Error processing webpage: {str(e)}\")\n",
            "name": "fetch_webpage",
            "description": "Fetch a webpage and convert it to markdown format, with options for including images and limiting length",
            "global_imports": [
              {
                "module": "typing",
                "imports": ["Optional", "Dict"]
              },
              {
                "module": "requests",
                "imports": ["get", "RequestException"]
              },
              {
                "module": "bs4",
                "imports": ["BeautifulSoup"]
              },
              {
                "module": "html2text",
                "imports": ["HTML2Text"]
              },
              {
                "module": "urllib.parse",
                "imports": ["urljoin"]
              }
            ],
            "has_cancellation_support": false
          }
        },
        {
          "provider": "autogen_core.tools.FunctionTool",
          "component_type": "tool",
          "version": 1,
          "component_version": 1,
          "description": "A tool that performs Bing searches using the Bing Web Search API. Requires the requests library, BING_SEARCH_KEY env variable to function.",
          "label": "Bing Search Tool",
          "config": {
            "source_code": "async def bing_search(\n    query: str,\n    num_results: int = 5,\n    include_snippets: bool = True,\n    language: str = \"en\",\n    country: Optional[str] = None,\n    safe_search: str = \"moderate\",\n    response_filter: str = \"webpages\"\n) -> List[Dict[str, str]]:\n    \"\"\"\n    Perform a Bing search using the Bing Web Search API. \n\n    Args:\n        query: Search query string\n        num_results: Number of results to return (max 50)\n        include_snippets: Include result snippets in output\n        language: Language code for search results (e.g., 'en', 'es', 'fr')\n        country: Optional market code for search results (e.g., 'us', 'uk')\n        safe_search: SafeSearch setting ('off', 'moderate', or 'strict')\n        response_filter: Type of results ('webpages', 'news', 'images', or 'videos')\n\n    Returns:\n        List[Dict[str, str]]: List of search results\n\n    Raises:\n        ValueError: If API credentials are invalid or request fails\n    \"\"\"\n    # Get and validate API key\n    api_key = os.getenv('BING_SEARCH_KEY', '').strip()\n\n    if not api_key:\n        raise ValueError(\n            \"BING_SEARCH_KEY environment variable is not set. \"\n            \"Please obtain an API key from Azure Portal.\"\n        )\n\n    # Validate safe_search parameter\n    valid_safe_search = ['off', 'moderate', 'strict']\n    if safe_search.lower() not in valid_safe_search:\n        raise ValueError(\n            f\"Invalid safe_search value. Must be one of: {', '.join(valid_safe_search)}\"\n        )\n\n    # Validate response_filter parameter\n    valid_filters = ['webpages', 'news', 'images', 'videos']\n    if response_filter.lower() not in valid_filters:\n        raise ValueError(\n            f\"Invalid response_filter value. Must be one of: {', '.join(valid_filters)}\"\n        )\n\n    # Build request headers and parameters\n    headers = {\n        'Ocp-Apim-Subscription-Key': api_key,\n        'Accept': 'application/json'\n    }\n\n    params = {\n        'q': query,\n        'count': min(max(1, num_results), 50),\n        'mkt': f'{language}-{country.upper()}' if country else language,\n        'safeSearch': safe_search.capitalize(),\n        'responseFilter': response_filter,\n        'textFormat': 'raw'\n    }\n\n    # Make the request\n    try:\n        response = requests.get(\n            'https://api.bing.microsoft.com/v7.0/search',\n            headers=headers,\n            params=params,\n            timeout=10\n        )\n\n        # Handle common error cases\n        if response.status_code == 401:\n            raise ValueError(\n                \"Authentication failed. Please verify your Bing Search API key.\"\n            )\n        elif response.status_code == 403:\n            raise ValueError(\n                \"Access forbidden. This could mean:\\n\"\n                \"1. The API key is invalid\\n\"\n                \"2. The API key has expired\\n\"\n                \"3. You've exceeded your API quota\"\n            )\n        elif response.status_code == 429:\n            raise ValueError(\"API quota exceeded. Please try again later.\")\n\n        response.raise_for_status()\n        data = response.json()\n\n        # Process results based on response_filter\n        results = []\n        if response_filter == 'webpages' and 'webPages' in data:\n            items = data['webPages']['value']\n        elif response_filter == 'news' and 'news' in data:\n            items = data['news']['value']\n        elif response_filter == 'images' and 'images' in data:\n            items = data['images']['value']\n        elif response_filter == 'videos' and 'videos' in data:\n            items = data['videos']['value']\n        else:\n            if not any(key in data for key in ['webPages', 'news', 'images', 'videos']):\n                return []  # No results found\n            raise ValueError(f\"No {response_filter} results found in API response\")\n\n        # Extract relevant information based on result type\n        for item in items:\n            result = {'title': item.get('name', '')}\n\n            if response_filter == 'webpages':\n                result['link'] = item.get('url', '')\n                if include_snippets:\n                    result['snippet'] = item.get('snippet', '')\n\n            elif response_filter == 'news':\n                result['link'] = item.get('url', '')\n                if include_snippets:\n                    result['snippet'] = item.get('description', '')\n                result['date'] = item.get('datePublished', '')\n\n            elif response_filter == 'images':\n                result['link'] = item.get('contentUrl', '')\n                result['thumbnail'] = item.get('thumbnailUrl', '')\n                if include_snippets:\n                    result['snippet'] = item.get('description', '')\n\n            elif response_filter == 'videos':\n                result['link'] = item.get('contentUrl', '')\n                result['thumbnail'] = item.get('thumbnailUrl', '')\n                if include_snippets:\n                    result['snippet'] = item.get('description', '')\n                result['duration'] = item.get('duration', '')\n\n            results.append(result)\n\n        return results[:num_results]\n\n    except requests.RequestException as e:\n        error_msg = str(e)\n        if \"InvalidApiKey\" in error_msg:\n            raise ValueError(\n                \"Invalid API key. Please check your BING_SEARCH_KEY environment variable.\"\n            )\n        elif \"KeyExpired\" in error_msg:\n            raise ValueError(\"API key has expired. Please generate a new key.\")\n        else:\n            raise ValueError(f\"Search request failed: {error_msg}\")\n    except json.JSONDecodeError:\n        raise ValueError(\n            \"Failed to parse API response. \"\n            \"Please verify your API credentials and try again.\"\n        )\n    except Exception as e:\n        raise ValueError(f\"Unexpected error during search: {str(e)}\")\n",
            "name": "bing_search",
            "description": "\n    Perform Bing searches using the Bing Web Search API. \n    Requires BING_SEARCH_KEY environment variable.\n    Supports web, news, image, and video searches.\n    See function documentation for detailed setup instructions.\n    ",
            "global_imports": [
              {
                "module": "typing",
                "imports": ["List", "Dict", "Optional"]
              },
              {
                "module": "os",
                "imports": ["getenv"]
              },
              {
                "module": "requests",
                "imports": ["get", "RequestException"]
              },
              {
                "module": "json",
                "imports": ["JSONDecodeError"]
              }
            ],
            "has_cancellation_support": false
          }
        },
        {
          "provider": "autogen_core.tools.FunctionTool",
          "component_type": "tool",
          "version": 1,
          "component_version": 1,
          "description": "A tool that performs Google searches using the Google Custom Search API. Requires the requests library, [GOOGLE_API_KEY, GOOGLE_CSE_ID] to be set,  env variable to function.",
          "label": "Google Search Tool",
          "config": {
            "source_code": "async def google_search(\n    query: str,\n    num_results: int = 5,\n    include_snippets: bool = True,\n    language: str = \"en\",\n    country: Optional[str] = None,\n    safe_search: bool = True\n) -> List[Dict[str, str]]:\n    \"\"\"\n    Perform a Google search using the Custom Search API.    \n    Args:\n        query: Search query string\n        num_results: Number of results to return (max 10)\n        include_snippets: Include result snippets in output\n        language: Language code for search results (e.g., 'en', 'es', 'fr')\n        country: Optional country code for search results (e.g., 'us', 'uk')\n        safe_search: Enable safe search filtering\n\n    Returns:\n        List[Dict[str, str]]: List of search results, each containing:\n            - title: Result title\n            - link: Result URL\n            - snippet: Result description (if include_snippets=True)\n\n    Raises:\n        ValueError: If API keys are missing or invalid, or if the request fails\n    \"\"\"\n    # Get API credentials\n    api_key = os.getenv('GOOGLE_API_KEY')\n    cse_id = os.getenv('GOOGLE_CSE_ID')\n\n    if not api_key or not cse_id:\n        raise ValueError(\n            \"Missing required environment variables. Please set GOOGLE_API_KEY and GOOGLE_CSE_ID. \"\n            \"See function documentation for setup instructions.\"\n        )\n\n    # Ensure num_results is within allowed range\n    num_results = min(max(1, num_results), 10)\n\n    # Build request parameters\n    params = {\n        'key': api_key,\n        'cx': cse_id,\n        'q': query,\n        'num': num_results,\n        'hl': language,\n        'safe': 'active' if safe_search else 'off',\n    }\n\n    if country:\n        params['gl'] = country\n\n    # Make the request\n    try:\n        response = requests.get(\n            'https://www.googleapis.com/customsearch/v1',\n            params=params,\n            timeout=10\n        )\n        response.raise_for_status()\n        data = response.json()\n\n        # Process results\n        results = []\n        if 'items' in data:\n            for item in data['items']:\n                result = {\n                    'title': item.get('title', ''),\n                    'link': item.get('link', '')\n                }\n                if include_snippets:\n                    result['snippet'] = item.get('snippet', '')\n                results.append(result)\n\n        return results\n\n    except requests.RequestException as e:\n        raise ValueError(f\"Failed to perform search: {str(e)}\")\n    except KeyError as e:\n        raise ValueError(f\"Invalid API response format: {str(e)}\")\n    except Exception as e:\n        raise ValueError(f\"Error during search: {str(e)}\")\n",
            "name": "google_search",
            "description": "\n    Perform Google searches using the Custom Search API. \n    Requires GOOGLE_API_KEY and GOOGLE_CSE_ID environment variables to be set.\n    See function documentation for setup instructions.\n    ",
            "global_imports": [
              {
                "module": "typing",
                "imports": ["List", "Dict", "Optional"]
              },
              {
                "module": "os",
                "imports": ["getenv"]
              },
              {
                "module": "requests",
                "imports": ["get", "RequestException"]
              }
            ],
            "has_cancellation_support": false
          }
        }
      ],
      "terminations": [
        {
          "provider": "autogen_agentchat.conditions.TextMentionTermination",
          "component_type": "termination",
          "version": 1,
          "component_version": 1,
          "description": "Terminate the conversation if a specific text is mentioned.",
          "label": "TextMentionTermination",
          "config": {
            "text": "TERMINATE"
          }
        },
        {
          "provider": "autogen_agentchat.conditions.MaxMessageTermination",
          "component_type": "termination",
          "version": 1,
          "component_version": 1,
          "description": "Terminate the conversation after a maximum number of messages have been exchanged.",
          "label": "MaxMessageTermination",
          "config": {
            "max_messages": 10
          }
        },
        {
          "provider": "autogen_agentchat.base.OrTerminationCondition",
          "component_type": "termination",
          "version": 1,
          "component_version": 1,
          "description": null,
          "label": "OrTerminationCondition",
          "config": {
            "conditions": [
              {
                "provider": "autogen_agentchat.conditions.TextMentionTermination",
                "component_type": "termination",
                "version": 1,
                "component_version": 1,
                "description": "Terminate the conversation if a specific text is mentioned.",
                "label": "TextMentionTermination",
                "config": {
                  "text": "TERMINATE"
                }
              },
              {
                "provider": "autogen_agentchat.conditions.MaxMessageTermination",
                "component_type": "termination",
                "version": 1,
                "component_version": 1,
                "description": "Terminate the conversation after a maximum number of messages have been exchanged.",
                "label": "MaxMessageTermination",
                "config": {
                  "max_messages": 10
                }
              }
            ]
          }
        }
      ]
    }
  }
}
